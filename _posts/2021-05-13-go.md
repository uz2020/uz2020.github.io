---
layout: post
title:  "Go"
---

## go数据类型

integer中，int、uint是最通用的，编译时会根据平台决定使用最高效的空间表
示，可能是4字节也可能是8字节。

如果要指定地更详细一些，就用int8、int16、int32、int64，或者uint8、
uint16、uint32、uint64。

要存储C语言中的long的最大值，int和uint都是可以的。因此通常而言就不必再
指定使用int32之类的了。

## go struct member名字映射

假设我们定义了一个struct，这个struct用于存放json数据，我们不希望手动地
写一堆无聊的赋值，而是希望有工具可以帮我们通过struct和json中member的名
称的对照关系实现自动赋值。这种对照关系放在哪里呢？C语言的struct无法指
定，但Go考虑到这个需求，所以它由特殊的语法来支持。

## go版本问题

才发现原来只要go版本相同，编译之后就可以放到对应平台上执行了。我本地的
go版本是1.16，而服务器上是1.15。本地编译之后的程序放在服务器上报错说动
态库版本不匹配

```
./app: /lib64/libc.so.6: version `GLIBC_2.32' not found (required by ./app)
```

但我不可能为了服务器去调整自己本地的环境，所以我就用docker拉了一个1.15
的golang image，编译之后竟然就可以在服务器上跑了。

在此之前我曾愚蠢地用docker去构建一个和服务器相同的环境，也就是在
centos7安装golang。后来发现这真是多余。只要把golang的官方镜像拉下来就
可以编译了。

## enum

[enum best practice](https://yourbasic.org/golang/iota/)

## 配置文件

## gin

gin内容会比较多，这里简单地研究一下。后续另开一篇专门研究。

## 后台运行

## 日志

很多框架都有middleware的概念，目的都是为了扩展框架功能。gin也不例外。

为了方便使用gin框架，作者提供的gin.Default()函数所创建的engine已经包含
了一些常用的middleware了，如Logger。而gin.New()创建的就是空engine。空
engine自然是不会自己打印日志的。需要在执行e.Use(gin.Logger())之后，空
engine才不再是空engine，而是具备了日志功能的engine（*e表示该engine*）。

为了验证上面这段话的思路，现在就编译。既然docker提供环境编译，那我就在
docker容器里编译了，因为这样不会影响到本地环境。但有一个问题是，docker
编译好的文件未必会马上同步到host。也许有参数可以强制同步，但我目前没发
现。于是就出现了几次明明已经编译了，可执行文件却还是旧的情况。导致我上
面的思路得不到验证。于是改变策略，乖乖地在本地编译。很快就验证了我的思
路没问题。

言归正传，gin.DefaultWriter是os.stdout，因此日志打印在了屏幕上。如果想
要输出到文件怎么办？有办法，那就是

```go
	f, _ := os.Create("gin.log")
	gin.DefaultWriter = io.MultiWriter(f)
```

现在日志确实输出到文件了，那么如果我希望它屏幕和文件都同时输出呢？这个
需求稍后再研究。随着我们的需求越来越复杂，代码也引出了更多可以研究的东
西。

1. os、io两个package分别负责什么？为什么用os.Create创建文件，而不是
   io.Create？
2. e.Use(gin.Logger())，这里传入的参数是gin.Logger()，那么gin.Logger()
   返回的是什么？是否可以通过gin.Logger()来得到一些特定的logger？比如
   能够控制日志格式的logger？
3. io.MultiWriter() 这是什么意思？是否这里可以控制日志输出到多个地方？

## mysql连接

## rabbitmq连接

## oauth2.0

## cmd

## micro

## https/ssl

## http2

## http

## websocket

## 发起http请求
