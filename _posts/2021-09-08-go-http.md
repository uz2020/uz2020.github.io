---
layout: post
title: go net/http
---

## ListenAndServe

有两种写法

```go
	myHandler := &handler{}
	s := &http.Server{
		Addr:    ":8080",
		Handler: myHandler,
	}

	s.ListenAndServe()
```

```go
	h := &handler{}
	http.ListenAndServe(":8088", h)
```

其实后者是前者的一个wrapper而已。

```go
func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}
```

## Handler interface

有两种写法

(使用DefaultServeMux, multiplexer)

```go
	http.Handle("/foo", fooHandler) // 使用Handler interface
	http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
	}) // 设置回调函数
	log.Fatal(http.ListenAndServe(":8080", nil))
```

(实现Handler interface, 不是用multiplexer)

```go
type handler struct{}
func (h *handler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	print(h)
}

	s := &http.Server{
		Addr:    ":8080",
		Handler: myHandler,
	}
```

### 实现

1. http.Handle
2. http.HandleFunc

如果是传入回调函数的方式，就会将该回调函数cast为HandlerFunc，因为HandlerFunc和实现了ServeHTTP，满足Handler interface。然后1、2两种方式设置的回调函数就可以用同样的逻辑来处理了。

```go
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}

func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	if handler == nil {
		panic("http: nil handler")
	}
	mux.Handle(pattern, HandlerFunc(handler))
}
```

这两个函数用到的都是default multiplexer。用一个map来保存pattern和回调函数的关系。因为default multiplexer是全局的，修改map时要上锁。

```go
func (mux *ServeMux) Handle(pattern string, handler Handler) {
	mux.mu.Lock()
	defer mux.mu.Unlock()

	if mux.m == nil {
		mux.m = make(map[string]muxEntry)
	}
    
	e := muxEntry{h: handler, pattern: pattern}
	mux.m[pattern] = e
```

## DefaultServeMux

当然我们可以直接实现一个Handler，但它啥都没有。如果使用ServeMux，就可以用上现成的路由。

如果在一个程序中开多个http server，就要避免共用同一个DefaultServeMux。

否则各服务器之间的路由是冲突的:

```
panic: http: multiple registrations for /
```

下面的写法里，两个http服务器都有自己的multiplexer，因而不会冲突：

```go
func main() {
	wg := sync.WaitGroup{}
	wg.Add(1)
	go func() {
		s := http.ServeMux{}
		s.HandleFunc("/", func(rw http.ResponseWriter, r *http.Request) {
			fmt.Println("good")
		})
		http.ListenAndServe(":8080", &s)
		wg.Done()
	}()
	wg.Add(1)
	go func() {
		s := http.ServeMux{}
		s.HandleFunc("/", func(rw http.ResponseWriter, r *http.Request) {
			fmt.Println("bad")
		})
		http.ListenAndServe(":8081", &s)
		wg.Done()
	}()

	wg.Wait()
}
```

multiplexer本质也是Handler，只不过它的ServeHTTP实现了路由的逻辑。

## 实现

前面研究的都是很肤浅的内容，现在再仔细看看net/http是怎么实现的。

如果一个http package只是实现http server的功能，没有路由功能的话，是没有吸引力的吧。所以net/http出产就提供了一个已经实现路由机制的ServeMux，当然用不用它取决于用户。

按照以前的编程思路，当我们把框架搭好了，在合适的地方允许用户提供他们的逻辑时，我们主要是用回调函数的方式。但是回调函数的问题在于它没有内部数据，所有的逻辑都要堆砌在一个函数中。

因此net/http的一些重要函数只要求我们提供一个Handler接口，至于是用什么实现的Handler，它并不关心。

net/http中就有两种Handler的实现:
1. ServeMux: struct, 考虑得更多
2. HandlerFunc: func, 只关心逻辑

当然我们也可以提供自己的实现。

然而ServeMux本身不提供处理http请求的业务逻辑，它只是把请求路由到对应的handler而已。在match pattern之后，真正去执行业务逻辑的还是回调函数。而回调函数提供的方式也是提供一个Handler接口的对象。


```go
func (mux *ServeMux) Handle(pattern string, handler Handler) {
```

```go
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	if handler == nil {
		panic("http: nil handler")
	}
	mux.Handle(pattern, HandlerFunc(handler))
}

func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
	if r.RequestURI == "*" {
		if r.ProtoAtLeast(1, 1) {
			w.Header().Set("Connection", "close")
		}
		w.WriteHeader(StatusBadRequest)
		return
	}
	h, _ := mux.Handler(r)
	h.ServeHTTP(w, r) // 关键时刻还是调用回调函数，ServeMux相当于一个wrapper
}
```

一些内部的Handler的实现
1. serverHandler
2. timeoutHandler
3. globalOptionsHandler
4. initALPNRequest


### conn

ListenAndServe()最后一步的serve是一个Accept()死循环。Accept获得的net.Conn需要在封装之后才能供http使用。

封装之后，最后一步(c是一个conn，http package封装的一个类型)：

```go
		go c.serve(connCtx)
```

这样每个请求都由一个goroutine处理实现并发。(但Accept这里如何并发呢?)

c自然包含了net.Conn，不过除此之外还有别的。


c的初始化:

(rwc是net.Conn, go developer喜欢用newConn这样的方式来创建一个对象)

```go
func (srv *Server) newConn(rwc net.Conn) *conn {
	c := &conn{
		server: srv,
		rwc:    rwc,
	}
```

c.serve()会在关键时刻执行handler的ServeHTTP()。当然找到这一行是意料之中，没什么意思。有意思的是，在执行ServeHTTP()之前，serve()究竟做了什么工作:
1. https的处理
2. c.readRequest()
3. 100 continue

通过type assert，得知Accept返回的net.Conn是net.TCPConn还是tls.Conn。从而确定是否https。如果是，则进行tls handshake。在handshake之前，要设置超时时间。

```go
	if tlsConn, ok := c.rwc.(*tls.Conn); ok {
		if d := c.server.ReadTimeout; d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
		}
		if d := c.server.WriteTimeout; d != 0 {
			c.rwc.SetWriteDeadline(time.Now().Add(d))
		}
		if err := tlsConn.Handshake(); err != nil {
```

疑问
1. 超时会发生什么? 
2. Accept又是如何判断Conn类型的? 
3. handshake之后应该做什么?

### Accept返回的是net.TCPConn还是tls.Conn?

为了回答这个问题，必须回到Listener的问题上。

ListenAndserve:

```go
func (srv *Server) ListenAndServe() error {
	if srv.shuttingDown() {
		return ErrServerClosed
	}
	addr := srv.Addr
	if addr == "" {
		addr = ":http"
	}
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}
	return srv.Serve(ln)
}
```

ListenAndserveTLS:

```go
func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServeTLS(certFile, keyFile)
}

func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error {
	if srv.shuttingDown() {
		return ErrServerClosed
	}
	addr := srv.Addr
	if addr == "" {
		addr = ":https"
	}

	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}

	defer ln.Close()

	return srv.ServeTLS(ln, certFile, keyFile)
}

func (srv *Server) ServeTLS(l net.Listener, certFile, keyFile string) error {
	tlsListener := tls.NewListener(l, config)
	return srv.Serve(tlsListener)
}

func (l *listener) Accept() (net.Conn, error) {
	c, err := l.Listener.Accept()
	if err != nil {
		return nil, err
	}
	return Server(c, l.config), nil
}

// tls.go
func Server(conn net.Conn, config *Config) *Conn {
	c := &Conn{
		conn:   conn,
		config: config,
	}
	c.handshakeFn = c.serverHandshake
	return c
}
```

两者都是先通过net.Listen获取一个基础的listener。而tls在listener基础上进行了改良。tls返回的Conn是一个wrapper，在基础listener之上又包含了handshakeFn、config等信息。

在使用api的过程中，我们必须通过显式地调用ListenAndServeTLS来告知net/http我们想要的是https服务器。


因而在c.serve()中，发现Conn是tls的Conn时，会调用Handshake()函数。

那么handshake发生了什么事情呢? 以往我读https RFC读得晕头转向，这下读源码，或许效果会好一些。

#### server handshake

handshake分为client和server side。

核心逻辑在handshakeFn这个回调函数中。

回顾之前的代码得知逻辑在c.serverHandshake():

```go
// tls.go
func Server(conn net.Conn, config *Config) *Conn {
	c := &Conn{
		conn:   conn,
		config: config,
	}
	c.handshakeFn = c.serverHandshake
	return c
}
```


```go
func (c *Conn) serverHandshake() error {
	clientHello, err := c.readClientHello()
	if err != nil {
		return err
	}

	if c.vers == VersionTLS13 {
		hs := serverHandshakeStateTLS13{
			c:           c,
			clientHello: clientHello,
		}
		return hs.handshake()
	}

	hs := serverHandshakeState{
		c:           c,
		clientHello: clientHello,
	}
	return hs.handshake()
}
```

可见，tls也分几个版本。

##### tls 1.3

server

```go
func (hs *serverHandshakeStateTLS13) handshake() error {
	c := hs.c

	// For an overview of the TLS 1.3 handshake, see RFC 8446, Section 2.
	if err := hs.processClientHello(); err != nil {
		return err
	}
	if err := hs.checkForResumption(); err != nil {
		return err
	}
	if err := hs.pickCertificate(); err != nil {
		return err
	}
	c.buffering = true
	if err := hs.sendServerParameters(); err != nil {
		return err
	}
	if err := hs.sendServerCertificate(); err != nil {
		return err
	}
	if err := hs.sendServerFinished(); err != nil {
		return err
	}
	// Note that at this point we could start sending application data without
	// waiting for the client's second flight, but the application might not
	// expect the lack of replay protection of the ClientHello parameters.
	if _, err := c.flush(); err != nil {
		return err
	}
	if err := hs.readClientCertificate(); err != nil {
		return err
	}
	if err := hs.readClientFinished(); err != nil {
		return err
	}

	atomic.StoreUint32(&c.handshakeStatus, 1)

	return nil
}
```

client

```go
func (hs *clientHandshakeStateTLS13) handshake() error {
	c := hs.c

	// The server must not select TLS 1.3 in a renegotiation. See RFC 8446,
	// sections 4.1.2 and 4.1.3.
	if c.handshakes > 0 {
		c.sendAlert(alertProtocolVersion)
		return errors.New("tls: server selected TLS 1.3 in a renegotiation")
	}

	// Consistency check on the presence of a keyShare and its parameters.
	if hs.ecdheParams == nil || len(hs.hello.keyShares) != 1 {
		return c.sendAlert(alertInternalError)
	}

	if err := hs.checkServerHelloOrHRR(); err != nil {
		return err
	}

	hs.transcript = hs.suite.hash.New()
	hs.transcript.Write(hs.hello.marshal())

	if bytes.Equal(hs.serverHello.random, helloRetryRequestRandom) {
		if err := hs.sendDummyChangeCipherSpec(); err != nil {
			return err
		}
		if err := hs.processHelloRetryRequest(); err != nil {
			return err
		}
	}

	hs.transcript.Write(hs.serverHello.marshal())

	c.buffering = true
	if err := hs.processServerHello(); err != nil {
		return err
	}
	if err := hs.sendDummyChangeCipherSpec(); err != nil {
		return err
	}
	if err := hs.establishHandshakeKeys(); err != nil {
		return err
	}
	if err := hs.readServerParameters(); err != nil {
		return err
	}
	if err := hs.readServerCertificate(); err != nil {
		return err
	}
	if err := hs.readServerFinished(); err != nil {
		return err
	}
	if err := hs.sendClientCertificate(); err != nil {
		return err
	}
	if err := hs.sendClientFinished(); err != nil {
		return err
	}
	if _, err := c.flush(); err != nil {
		return err
	}

	atomic.StoreUint32(&c.handshakeStatus, 1)

	return nil
}
```


##### tls 1.0/1.1/1.2


```go
func (hs *serverHandshakeState) handshake() error {
	c := hs.c

	if err := hs.processClientHello(); err != nil {
		return err
	}

	// For an overview of TLS handshaking, see RFC 5246, Section 7.3.
	c.buffering = true
	if hs.checkForResumption() {
		// The client has included a session ticket and so we do an abbreviated handshake.
		c.didResume = true
		if err := hs.doResumeHandshake(); err != nil {
			return err
		}
		if err := hs.establishKeys(); err != nil {
			return err
		}
		if err := hs.sendSessionTicket(); err != nil {
			return err
		}
		if err := hs.sendFinished(c.serverFinished[:]); err != nil {
			return err
		}
		if _, err := c.flush(); err != nil {
			return err
		}
		c.clientFinishedIsFirst = false
		if err := hs.readFinished(nil); err != nil {
			return err
		}
	} else {
		// The client didn't include a session ticket, or it wasn't
		// valid so we do a full handshake.
		if err := hs.pickCipherSuite(); err != nil {
			return err
		}
		if err := hs.doFullHandshake(); err != nil {
			return err
		}
		if err := hs.establishKeys(); err != nil {
			return err
		}
		if err := hs.readFinished(c.clientFinished[:]); err != nil {
			return err
		}
		c.clientFinishedIsFirst = true
		c.buffering = true
		if err := hs.sendSessionTicket(); err != nil {
			return err
		}
		if err := hs.sendFinished(nil); err != nil {
			return err
		}
		if _, err := c.flush(); err != nil {
			return err
		}
	}

	c.ekm = ekmFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random)
	atomic.StoreUint32(&c.handshakeStatus, 1)

	return nil
}

```
