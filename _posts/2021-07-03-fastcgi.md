---
layout: post
---

之前部署lnmp都是在本机，现在在docker上部署，发现路径容易出问题。

来看看docker-compose文件里volumes的相关定义：

```yml
version: "3"
services:
  mysql:
    hostname: mysql
    restart: always
    image: mysql:5.7
    container_name: mysql
    ports:
      - "127.0.0.1:3306:3306"
    volumes:
      - mysql-config:/etc/mysql
      - mysql-log:/var/log/mysql
      - mysql-data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: redhat
      MYSQL_USER: admin
      MYSQL_PASSWORD: redhat
  php:
    hostname: php
    restart: always
    container_name: php
    image: bitnami/php-fpm:7.4-prod
    ports:
      - "127.0.0.1:9000:9000"
    links:
      - mysql:mysql
    volumes:
      - nginx-html:/var/www/html
      - php-config:/usr/local/etc
  nginx:
    hostname: nginx
    restart: always
    container_name: nginx
    image: nginx:1.19.0
    ports:
      - "80:80"
      - "443:443"
    links:
      - "php:php"
    volumes:
      - nginx-config:/etc/nginx
      - nginx-log:/var/log/nginx
      - nginx-html:/usr/share/nginx/html

volumes:
  mysql-config:
  mysql-log:
  mysql-data:
  nginx-html:
  php-config:
  nginx-config:
  nginx-log:
```

之前没仔细去看，今天帮同事解决路径的一点问题时，才发现这里的设置有讲究。

为什么会有两个nginx-html的映射定义？


```
      - nginx-html:/var/www/html
      - nginx-html:/usr/share/nginx/html
```

因为冒号前面的路径是本机路径，后面的是容器的路径。那就相当于php这个容器把它的/var/www/html路径映射成本机的nginx-html路径。而nginx容器则把它的/usr/share/nginx/html路径映射成本机的nginx-html路径。这就意味着nginx-html目录是两个容器都要去访问的。

在平时没有使用docker时，这两个路径在本机实际上是同一个路径，php-fpm和nginx都可以用同样的路径名访问到里面的文件。而采用了docker的方式部署以后，这里面的文件要保持两个容器都能继续访问，所以docker-compose.yml文件才把它们都映射到本机的nginx-html了。

那么在nginx配置文件里root的路径究竟填什么？首先排除的就是nginx-html，因为它是本机的路径，和容器没有一点关系。那么如果填/usr/share/nginx/html呢？这样是可以的，但问题是，如果请求的是php文件呢？php-fpm容器并不能通过/usr/share/nginx/html访问到php文件。

来看看配置示例：

```nginx

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

    location ~ \.php$ {
        fastcgi_pass   php:9000;
        fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;
        include        fastcgi_params;
    }

```

平时我们的配置一般都是root和SCRIPT_FILENAME的路径是差不多的，但现在显然不同了。为什么会这样？在处理静态文件请求时，nginx需要找到文件，它从它自己容器里的路径里找：/usr/share/nginx/html。但在处理php请求时，nginx并不检查php文件是否存在，而是通过反向代理到php-fpm，并且通过fastcgi协议把要请求的文件路径名传递给php-fpm。至于文件是否存在，那就是由php-fpm自己去找了。所以php-fpm自然要从它所属的容器的路径里面去找php文件，也就是在/var/www/html里。

docker-compose.yml把两个容器用到的目录都映射到了本机的同一个路径，确实造成了混淆。其实是可以映射到不同的路径的。这个路径问题也让我的同事搞了半天都没有配好。这个问题的关键在于要理解到是两个不同的容器来提供服务，它们的路径是不同的。也要知道fastcgi协议是通过参数来传递文件名的。

以前我一直搞不清楚nginx和fastcgi是怎么互动的，我甚至认为nginx会去寻找php文件，然后把文件传递过去给php-fpm去执行，得到结果。原来根本就不是这样玩的。
