---
layout: post
title: go channel
---

如果按照go推荐的做法，goroutine之间的交互全部通过channel消息，那么为什么还会有人使用传统的sync方式? 通过channel通信的好处是monitor模式。某一块内存只由某个goroutine负责读写和返回。

可是这样也带来很多麻烦。本来一个函数就可以获取得到的信息，却得通过channel消息，就复杂起来了。

尤其是当需要传递的消息变得复杂起来，消息要怎么设计?

如何匹配请求的消息和响应的消息? 如果是跨服务器无法使用goroutine通信时，怎么知道一个响应对应于哪一个请求? 难道每个请求都带一个id，响应时也带上? 这样不就很麻烦了吗?

至少在本机，我找到了一个好方法。grep了一下go的内部实现，发现它有用到以下的写法：

```go
chan chan int
```

刚开始我不明白为什么这么写，觉得很复杂，实际上，这是一个很很重要的技巧。当我发送一条消息我希望阻塞地等待响应时，我可以临时创建一个channel，并且把这个临时channel通过channel的方式发送给另一个goroutine。那个goroutine处理了我们的请求之后，直接通过这个临时channel返回结果。

有了这个技巧，我的游戏对战平台的框架就有了进展了。player、roomManager、room、table、game的关系开始理清楚。

由于这次没有和http正面硬刚，反而后台的逻辑写的更清晰一些了。现在是先通过robot的方式来测试平台，让robot来玩游戏。

通过interface的方式，无论是robot还是真实的player都可以接入游戏。通过interface的方式，可以实现很多游戏，就像插件一样。

尽管如此，工作量还是很大的。我的框架设计肯定有很多没有考虑好的地方。之后要支持断线重连、游客登录、分布式等等。

之后的消息传输可能会变得复杂，不知道gRPC能不能派上用场。另外，消息队列、缓存、存储的接入也是很有意思的部分。

最后说一句，虽然go源码读起来很耗时，但它能给我们的思路，是在网络上搜索所不能比的。现在断了网络，让我可以更加专注源码，少了忧虑，多了思考。可以花很多时间来发现别人在代码中留下的有趣的天马行空的想法。这些作者真的很有想象力。

我的文笔还是一如既往地差，但思绪来了，就顾不上了。以前我还很介意自己的文笔，却发现怎么也学不会别人的措辞。现在我已经放弃了，放飞自我，做回自己。
